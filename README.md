# Метод generate (общий случай)

В общем случае предполагается, что:

* количество типов юнитов `n` произвольно;
* максимальное количество юнитов каждого типа `m` произвольно;
* количество очков для формирования армии `points` также произвольно.

Для подбора оптимального состава армии используется жадный алгоритм.

## Суть алгоритма

1. Все типы юнитов сортируются по эффективности:
    * сначала по коэффициенту "атака / стоимость";
    * при равенстве - по коэффициенту "здоровье / стоимость".
2. После сортировки армия формируется последовательно:
    * для каждого типа юнита берётся максимально возможное количество юнитов, не превышающее лимит
      `n` и доступные очки `points`;
    * затем выполняется переход к следующему типу юнита.
3. Процесс продолжается до тех пор, пока не закончатся очки или доступные типы юнитов.

## Обоснование алгоритмической сложности

* сортировка типов юнитов выполняется за `O(n log n)`;
* добавление юнитов в армию выполняется за `O(n * m)`.

Итоговая сложность по времени алгоритма:

```
O(n log n + n * m)
```

По памяти алгоритм использует список создаваемых юнитов, что даёт сложность

```
O(n * m)
```

---

# Метод generate (оптимизированное решение)

> В условиях сказано "Алгоритмическая сложность должна быть O(n * m) или лучше"

В условиях заданы следующие конкретные ограничения:

* количество типов юнитов строго фиксировано и равно 4;
* характеристики каждого типа юнитов постоянны и не меняются;
* максимальное количество очков фиксировано и равно 1500;
* лимит на количество юнитов одного типа не превышает 11.

## Суть алгоритма

При таких условиях оптимальный состав армии всегда одинаков и может быть вычислен заранее.
Для заданных характеристик юнитов оптимальной конфигурацией является:

* 11 Всадников
* 11 Мечников
* 11 Копейщиков
* 9 Лучников

Суммарная стоимость данной армии составляет:

```
11 * 50 + 11 * 40 + 11 * 30 + 9 * 20 = 1500
```

## Обоснование алгоритмической сложности

В оптимизированной реализации:

* сортировка отсутствует;
* количество создаваемых юнитов заранее известно;
* выполняется фиксированное число операций.

Сложность по времени алгоритма равна сложности по памяти и составляет:

```
O(1)
```

---

# Метод simulate

## Суть алгоритма

Алгоритм реализует симуляцию боя в виде последовательных раундов.
В каждом раунде выполняются следующие шаги:

* Формируется список всех живых юнитов игрока и компьютера.
* Если хотя бы у одной из сторон не осталось живых юнитов, симуляция завершается.
* Все живые юниты сортируются по убыванию базовой атаки, что определяет очерёдность ходов.
* Каждый юнит в отсортированном списке выполняет атаку, если он жив на момент своего хода.
* Погибшие юниты автоматически исключаются из последующих раундов за счёт проверки isAlive().

Алгоритм корректно обрабатывает пограничные и нестандартные ситуации:

1. Юниты без цели - метод attack() вызывается за O(1) и сам отвечает за корректный выбор цели или
   отсутствие таковой.
2. Разное количество раундов - число итераций цикла while не фиксировано и зависит от хода боя.
3. Одновременные смерти - проверка unit.isAlive() перед атакой гарантирует, что погибший ранее в
   раунде юнит не совершит ход.
4. Пустая армия - бой завершается немедленно, если одна из сторон не добавила ни одного живого
   юнита.

## Обоснование алгоритмической сложности

Обозначим:

* n - максимальное количество юнитов в одной армии;
* m - количество раундов боя.

Один раунд включает:

| Операция                           | Сложность по времени | Сложность по памяти |
|------------------------------------|----------------------|---------------------|
| Сбор живых юнитов игрока           | O(n)                 | O(n)                |
| Сбор живых юнитов игрока           | O(n)                 | O(n)                |
| Сортировка живых юнитов            | O(n log n)           | O(n)                |
| Симуляция боя для собранных юнитов | O(n)                 | O(1)                |

Доминирующей операцией является сортировка, поэтому для m раундов сложность по времени:

```
O(m * n log n)
```

Поскольку количество раундов m ограничено числом возможных атак и убыванием общего здоровья юнитов,
в худшем случае `m = O(n)`, итоговая сложность алгоритма по времени:

```
O(n^2 log n)
```

Дополнительная память используется только для хранения списка живых юнитов текущего раунда,
поэтому сложность по памяти:

```
O(n)
```

---

# Метод getSuitableUnits

## Суть алгоритма

Метод определяет юнитов, доступных для атаки, для обеих армий:

* для армии компьютера - юнит армии игрока, который не закрыт справа другим юнитом армии игрока
* для армии игрока - юнит армии компьютера, который не закрыт слева другим юнитом армии компьютера
* добавляются только живые юниты, null-ячейки и мёртвые юниты не добавляются
* если все юниты вражеской армии мертвы - возвращается пустой список
* нет лишних сортировок или пересчетов, что позволяет интегрировать метод в процесс симуляции боя
  без деградации производительности
* используются структуры данных (множества на основе хэш-таблиц), операции над которыми производятся
  за константное время

## Обоснование алгоритмической сложности

Обозначим:

* n - максимальное число юнитов в ряду
* m - число рядов (всегда равно 3)

Осуществляется один проход по всем рядам и юнитам в ряду, что составляет сложность по времени:

```
O(n)
```

Дополнительная память используется только для хранения юнитов и их координаты, поэтому сложность по
памяти:

```
O(n)
```

---

# Метод getTargetPath

## Суть алгоритма

Метод для поиска кратчайшего пути для атакующего юнита до целевого юнита на игровом поле с
фиксированными размерами `WIDTH * HEIGHT`. Алгоритм учитывает следующие особенности:

* На поле могут находиться другие живые юниты, которые блокируют клетки - такие клетки отмечаются в
  `blockedCells`
* Для поиска пути используется модифицированный алгоритм Дейкстры: каждая доступная клетка
  рассматривается как узел графа, а расстояние до узла хранится в `Node.distanceFromStart`
* Узлы добавляются в очередь с приоритетом по минимальному расстоянию от стартовой позиции
* Соседние клетки проверяются по 8 направлениям (горизонтально, вертикально и диагонально)
* Если путь до цели существует, метод восстанавливает его от конечного узла к стартовому и
  возвращает в виде списка объектов `Edge`.
* Если путь недоступен, возвращается пустой список.

## Обоснование алгоритмической сложности

Для оценки сложности по времени необходимо зафиксировать:

* Размер поля - всего `W * H` клеток, поэтому в худшем случае алгоритм может обойти все `W * H`
  узлов
* Алгоритм использует очередь с приоритетом (`PriorityQueue`) для выбора узла с минимальным
  расстоянием от стартовой точки. Каждая операция извлечения (`poll`) и добавления (`offer`) в
  `PriorityQueue` имеет сложность `O(log k)`, где `k` - текущее количество элементов в очереди. В
  худшем случае `k <= W * H`, поэтому каждая операция вставки/извлечения требует `O(log(W * H))`
* Каждый узел может быть добавлен в очередь не более одного раза, потому что `createdNodes` хранит
  уже созданные узлы, и пересоздание происходит только при улучшении расстояния. Следовательно,
  максимальное число операций добавления/извлечения для всех узлов - `O(W * H)`.

Итоговая сложность по времени включает в себя извлечение из очереди + добавление новых узлов:
`O(log(W*H))` на узел, что при умножении на максимум `W * H` узлов даёт

```
O(W * H * log(W * H))
```

Сложность по памяти:

* Массив `blockedCells` - `O(W*H)`
* Мапа `createdNodes` - `O(W*H)`
* Очередь `nodesToVisit` - `O(W*H)`
* Список `пути` path - `O(W*H)`

Итоговая сложность по памяти:

```
O(W*H)
```